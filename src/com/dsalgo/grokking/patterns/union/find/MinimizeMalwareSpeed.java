package com.dsalgo.grokking.patterns.union.find;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

// https://leetcode.com/problems/minimize-malware-spread/
class UnionFind7 {
    int[] parents;
    int[] size;

    public UnionFind7(int n) {
        parents = new int[n];
        size = new int[n];

        for(int i = 0; i < n; i++) {
            parents[i] = i;
            size[i] = i;
        }
    }

    public int findParent(int x) {
        if(parents[x] == x) {
            return x;
        }
        return parents[x] = findParent(parents[x]);
    }

    public void union(int x, int y) {
        int xParent = findParent(x);
        int yParent = findParent(y);

        if(xParent != yParent) {
            parents[xParent] = yParent;
            size[yParent] += size[xParent];
        }
    }
}
public class MinimizeMalwareSpeed {
    public static void main(String[] args) {
        int[][] graph = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        int[] initial = {0, 2};

        System.out.println(minMalwareSpread(graph, initial));
    }

    private static int minMalwareSpread(int[][] graph, int[] initial) {
        // store the length of the graph
        int length = graph.length;

        UnionFind7 unionFind = new UnionFind7(length);

        // find all the connected components of the graph
        for(int x = 0; x < length; x++) {
            for(int y = 0; y < length; y++) {
                if(graph[x][y] == 1) {
                    unionFind.union(x, y);
                }
            }
        }

        Map<Integer, Integer> infected = new HashMap<>();
        Arrays.sort(initial);

        // count the number of initial infected nodes each connected component has
        for(int x = 0; x < initial.length; x++) {
            int findX = unionFind.findParent(initial[x]);
            infected.put(findX, infected.getOrDefault(findX, 0) + 1);
        }

        int candidateNode = initial[0];
        int maximumSize = 0;

        // count all the infected nodes each connected component has
        for(int i = 0; i < initial.length; i++) {
            int infectedCount = infected.get(unionFind.findParent(initial[i]));
            int componentSize = unionFind.size[unionFind.findParent(initial[i])];

            if(infectedCount != 1) {
                continue;
            }

            // return the candidate node from largest length connected component
            if(componentSize > maximumSize) {
                maximumSize = componentSize;
                candidateNode = initial[i];
            } else if (componentSize == maximumSize && initial[i] < candidateNode) {
                candidateNode = initial[i];
            }
        }
        return candidateNode;
    }
}
